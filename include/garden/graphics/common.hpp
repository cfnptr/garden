// Copyright 2022-2025 Nikita Fediuchin. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/***********************************************************************************************************************
 * @file
 * @brief Common graphics functions.
 */

#pragma once
#include "garden/defines.hpp"
#include "math/color.hpp"
#include "math/flags.hpp"

namespace garden::graphics
{

/**
 * @brief Nvidia architecture maximum binary size.
 */
constexpr psize maxPushConstantsSize = 128;

/***********************************************************************************************************************
 * @brief Point where programmable shading occurs.
 * 
 * @details 
 * Each stage is designed to perform a particular set of operations on the data that flows through the 
 * pipeline, allowing for flexible and powerful processing of graphics and compute tasks. 
 * The modern programmable graphics pipeline consists of multiple shader stages, each capable of 
 * running custom shader programs written in shading language.
 */
enum class ShaderStage : uint32
{
	None          = 0x0000, /**< No shader stage flags, zero mask. (0) */
	Vertex        = 0x0001, /**< Controls processing of vertex data. */
	Fragment      = 0x0002, /**< Operates on fragments generated by the rasterization process. */
	Compute       = 0x0004, /**< Performs general-purpose computing tasks. */
	RayGeneration = 0x0008, /**< Creates and launches rays into the scene. */
	Intersection  = 0x0010, /**< Handles ray intersection with custom geometry. */
	AnyHit        = 0x0020, /**< Invoked for every potential hit along a ray. */
	ClosestHit    = 0x0040, /**< Executed on a geometry hit, closes along the ray. */
	Miss          = 0x0080, /**< Handles rays that don't hit anything in the scene. */
	Callable      = 0x0100, /**< Invokable user defined ray tracing shader function. */
	Mesh          = 0x0200, /**< Generates group of meshlets. (vertices and primitives) */
	Task          = 0x0400  /**< Generates and dispatches work for mesh shader. */
};

constexpr uint8 shaderStageCount = 3; /**< Shader stage type count. */

/**
 * @brief Rendering pipeline type.
 * 
 * @details
 * Each pipeline type is optimized for a specific set of tasks and operations within the engine, 
 * reflecting the different requirements of rendering graphics and performing compute operations.
 * 
 * @todo Ray-Tracing pipeline support
 */
enum class PipelineType : uint8
{
	Graphics,   /**< Designed for rendering operations. */
	Compute,    /**< Designed for compute operations. */
	RayTracing, /** Designed for ray tracing operations. */ 
	Count       /**< Pipeline type count. */
};

/**
 * @brief Type of the index buffer indices.
 * @details Supported 16-bit and 32-bit unsigned integers.
 */
enum class IndexType : uint8
{
	Uint16, /**< 16-bit unsigned integer values. */
	Uint32, /**< 32-bit unsigned integer values. */
	Count   /**< Index buffer indices type count. */
};

/**
 * @brief Rendering command buffer type.
 * 
 * @details 
 * Command buffers are categorized into different types based on their submission and execution behavior. These 
 * types primarily differentiate how command buffers can be used within the rendering and computation processes.
 * 
 * @warning All command buffer types may have several frames delay!
 */
enum class CommandBufferType : uint8
{
	Frame,        /**< Current frame command buffer. */
	Graphics,     /**< Supports graphics, transfer and compute commands. */
	TransferOnly, /**< Supports transfer only commands. */
	Compute,      /**< Supports compute and transfer commands. */
	AsyncCompute, /**< Async compute command buffer, same support as compute. */
	Count         /**< Command buffer type count. */
};

DECLARE_ENUM_CLASS_FLAG_OPERATORS(ShaderStage)

/***********************************************************************************************************************
 * @brief Returns index buffer indices type size in bytes.
 * @param indexType target index buffer indices type
 */
static constexpr psize toBinarySize(IndexType indexType) noexcept
{
	switch (indexType)
	{
		case IndexType::Uint16: return sizeof(uint16);
		case IndexType::Uint32: return sizeof(uint32);
		default: return 0;
	}
}

/**
 * @brief Pipeline type name strings.
 */
constexpr const char* pipelineTypeNames[(psize)PipelineType::Count] =
{
	"Graphics", "Compute", "RayTracing"
};

/**
 * @brief Returns pipeline type.
 * @param pipelineType target pipeline type name (camelCase)
 * @throw GardenError on unknown pipeline type.
 */
static PipelineType toPipelineType(string_view pipelineType)
{
	if (pipelineType == "graphics") return PipelineType::Graphics;
	if (pipelineType == "compute") return PipelineType::Compute;
	if (pipelineType == "rayTracing") return PipelineType::RayTracing;
	throw GardenError("Unknown pipeline type. (" + string(pipelineType) + ")");
}
/**
 * @brief Returns pipeline type name string.
 * @param pipelineType target pipeline type
 */
static string_view toString(PipelineType pipelineType) noexcept
{
	GARDEN_ASSERT(pipelineType < PipelineType::Count);
	return pipelineTypeNames[(psize)pipelineType];
}

/**
 * @brief Returns shader stage name string.
 * @param samplerFilter target shader stage type
 */
static string_view toString(ShaderStage shaderStage) noexcept
{
	if (hasOneFlag(shaderStage, ShaderStage::Vertex)) return "Vertex";
	if (hasOneFlag(shaderStage, ShaderStage::Fragment)) return "Fragment";
	if (hasOneFlag(shaderStage, ShaderStage::Compute)) return "Compute";
	if (hasOneFlag(shaderStage, ShaderStage::RayGeneration)) return "RayGeneration";
	if (hasOneFlag(shaderStage, ShaderStage::Intersection)) return "Intersection";
	if (hasOneFlag(shaderStage, ShaderStage::AnyHit)) return "AnyHit";
	if (hasOneFlag(shaderStage, ShaderStage::ClosestHit)) return "ClosestHit";
	if (hasOneFlag(shaderStage, ShaderStage::Miss)) return "Miss";
	if (hasOneFlag(shaderStage, ShaderStage::Callable)) return "Callable";
	if (hasOneFlag(shaderStage, ShaderStage::Mesh)) return "Mesh";
	if (hasOneFlag(shaderStage, ShaderStage::Task)) return "Task";
	return "None";
}
/**
 * @brief Returns shader stage name list string.
 * @param samplerFilter target shader stage type
 */
static string toStringList(ShaderStage shaderStage) noexcept
{
	string list;
	if (hasAnyFlag(shaderStage, ShaderStage::Vertex)) list += "Vertex | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Fragment)) list += "Fragment | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Compute)) list += "Compute | ";
	if (hasAnyFlag(shaderStage, ShaderStage::RayGeneration)) list += "RayGeneration | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Intersection)) list += "Intersection | ";
	if (hasAnyFlag(shaderStage, ShaderStage::AnyHit)) list += "AnyHit | ";
	if (hasAnyFlag(shaderStage, ShaderStage::ClosestHit)) list += "ClosestHit | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Miss)) list += "Miss | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Callable)) list += "Callable | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Mesh)) list += "Mesh | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Task)) list += "Task | ";
	if (list.length() >= 3) list.resize(list.length() - 3);
	else return "None";
	return list;
}

/**
 * @brief Returns shader stage file extension.
 * @param shaderStage target shader stage
 */
static string_view toShaderStageExt(ShaderStage shaderStage)
{
	switch (shaderStage)
	{
		case ShaderStage::Vertex: return ".vert";
		case ShaderStage::Fragment: return ".frag";
		case ShaderStage::Compute: return ".comp";
		case ShaderStage::RayGeneration: return ".rgen";
		case ShaderStage::Intersection: return ".rint";
		case ShaderStage::AnyHit: return ".rahit";
		case ShaderStage::ClosestHit: return ".rchit";
		case ShaderStage::Miss: return ".rmiss";
		case ShaderStage::Callable: return ".rcall";
		case ShaderStage::Mesh: return ".mesh";
		case ShaderStage::Task: return ".task";
		default: throw GardenError("Unknown shader stage. (" + string(toString(shaderStage)) + ")");
	}
}

struct SvHash
{
	using is_transparent = void;
	std::size_t operator()(std::string_view sv) const { return std::hash<std::string_view>{}(sv); }
	std::size_t operator()(const std::string& str) const { return std::hash<std::string>{}(str); }
};
struct SvEqual
{
	using is_transparent = void;
	bool operator()(std::string_view lhs, std::string_view rhs) const noexcept { return lhs == rhs; }
};

#if GARDEN_DEBUG
/***********************************************************************************************************************
 * @brief Command buffer debug marker.
 * 
 * @details
 * Debug label is a tool used by developers to annotate resources, commands, and command groups with 
 * human-readable names or identifiers. These annotations do not affect the execution or performance 
 * of the application but serve as aids during the development and debugging process, making it easier 
 * to identify and troubleshoot issues within the complex flow of GPU operations.
 * 
 * @todo Add support of the queue labels.
 */
struct DebugLabel
{
	/**
	 * @brief Begins command buffer label region.
	 * 
	 * @param[in] name target region name
	 * @param color label color in the profiler
	 */
	static void begin(const string& name, Color color = Color::transparent);
	/**
	 * @brief Ends command buffer label region.
	 * @note Do not forget to end all label regions.
	 */
	static void end();

	/**
	 * @brief Inserts debug label.
	 * 
	 * @param[in] name target label name
	 * @param color label color in the profiler
	 */
	static void insert(const string& name, Color color = Color::transparent);

	/**
	 * @brief Creates and begins command buffer label region.
	 * 
	 * @param[in] name target region name
	 * @param color label color in the profiler
	 */
	DebugLabel(const string& name, Color color = Color::transparent) { begin(name, color); }
	/**
	 * @brief Ends command buffer label region.
	 * @note Use { } to set multiple labels in the same function.
	 */
	~DebugLabel() { end(); }
};

/**
 * @brief Creates and begins command buffer label region. (Debug Only)
 * @param[in] name target region name
 */
#define SET_GPU_DEBUG_LABEL(name) DebugLabel _debugLabel(name)
/**
 * @brief Creates and begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define SET_GPU_DEBUG_LABEL_C(name, color) DebugLabel _debugLabel(name, color)

/**
 * @brief Inserts debug label. (Debug Only)
 * @param[in] name target region name
 */
#define INSERT_GPU_DEBUG_LABEL(name) DebugLabel::insert(name)
/**
 * @brief Inserts debug label. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define INSERT_GPU_DEBUG_LABEL_C(name, color) DebugLabel::insert(name, color)

/**
 * @brief Begins command buffer label region. (Debug Only)
 * @param[in] name target region name
 */
#define BEGIN_GPU_DEBUG_LABEL(name) DebugLabel::begin(name)
/**
 * @brief Begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define BEGIN_GPU_DEBUG_LABEL_C(name, color) DebugLabel::begin(name, color)

/**
 * @brief Ends command buffer label region. (Debug Only)
 * @note Do not forget to end all debug labels!
 */
#define END_GPU_DEBUG_LABEL() DebugLabel::end()
#else
/**
 * @brief Creates and begins command buffer label region. (Debug Only)
 * @param[in] name target region name
 */
#define SET_GPU_DEBUG_LABEL(name) (void)0
/**
 * @brief Creates and begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define SET_GPU_DEBUG_LABEL_C(name, color) (void)0

/**
 * @brief Inserts debug label. (Debug Only)
 * @param[in] name target region name
 */
#define INSERT_GPU_DEBUG_LABEL(name) (void)0
/**
 * @brief Inserts debug label. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define INSERT_GPU_DEBUG_LABEL_C(name, color) (void)0

/**
 * @brief Begins command buffer label region. (Debug Only)
 * @param[in] name target region name
 */
#define BEGIN_GPU_DEBUG_LABEL(name) (void)0
/**
 * @brief Begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define BEGIN_GPU_DEBUG_LABEL_C(name, color) (void)0

/**
 * @brief Ends command buffer label region. (Debug Only)
 * @note Do not forget to end all debug labels!
 */
#define END_GPU_DEBUG_LABEL() (void)0
#endif

} // namespace garden::graphics