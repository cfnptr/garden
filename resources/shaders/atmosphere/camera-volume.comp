// Copyright 2022-2025 Nikita Fediuchin. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Physically based atmosphere camera volume scattering.
// Based on this: https://github.com/sebh/UnrealEngineSkyAtmosphere

#define USE_TRANSMITTANCE_LUT
#define USE_MULTI_SCATTERING_LUT
#define USE_SCAT_MIE_RAY_PHASE

spec const float SLICE_COUNT = 8.0f;
spec const float KM_PER_SLICE = 12.0f;

#include "common/depth.gsl"
#include "common/constants.gsl"
#include "atmosphere/common.gsl"

localSize = 8, 8, 1;

uniform sampler2D
{
	filter = linear;
} transLUT;
uniform sampler2D
{
	filter = linear;
} multiScatLUT;

uniform CommonConstants
{
	COMMON_CONSTANTS
} cc;

uniform writeonly restrict image3D cameraVolume : sfloatR16G16B16A16;

uniform pushConstants
{
	float3 rayleighScattering;
	float rayDensityExpScale;
	float3 mieExtinction;
	float mieDensityExpScale;
	float3 absorptionExtinction;
	float miePhaseG;
	float3 mieScattering;
	float absDensity0LayerWidth;
	float3 sunDir;
	float absDensity0ConstantTerm;
	float3 cameraPos;
	float absDensity0LinearTerm;
	float absDensity1ConstantTerm;
	float absDensity1LinearTerm;
	float bottomRadius;
	float topRadius;
} pc;

AtmosphereParams getAtmosphereParams()
{
	AtmosphereParams params;
	params.rayleighScattering = pc.rayleighScattering;
	params.rayDensityExpScale = pc.rayDensityExpScale;
	params.mieExtinction = pc.mieExtinction;
	params.mieDensityExpScale = pc.mieDensityExpScale;
	params.absorptionExtinction = pc.absorptionExtinction;
	params.absDensity0LayerWidth = pc.absDensity0LayerWidth;
	params.absDensity0ConstantTerm = pc.absDensity0ConstantTerm;
	params.absDensity0LinearTerm = pc.absDensity0LinearTerm;
	params.absDensity1ConstantTerm = pc.absDensity1ConstantTerm;
	params.absDensity1LinearTerm = pc.absDensity1LinearTerm;
	params.bottomRadius = pc.bottomRadius;
	params.topRadius = pc.topRadius;
	params.mieScattering = pc.mieScattering;
	params.miePhaseG = pc.miePhaseG;
	return params;
}

float aerialPerspSliceToDepth(float slice) { return slice * KM_PER_SLICE; }

//**********************************************************************************************************************
void main()
{
	AtmosphereParams atmosphere = getAtmosphereParams();
	float2 texCoords = (float2(gl.globalInvocationID.xy) + 0.5f) * (1.0f / CAMERA_VOLUME_LENGTH);
	float3 worldDir = calcViewDirection(0.5f, texCoords, cc.invViewProj);
	float slice = (float(gl.globalInvocationID.z) + 0.5f) * (1.0f / SLICE_COUNT);
	slice = slice * slice * SLICE_COUNT;

	// Compute position from froxel information.
	float tMaxMax = aerialPerspSliceToDepth(slice);
	float3 newWorldPos = fma(float3(tMaxMax), worldDir, pc.cameraPos);

	// If the voxel is under the ground, make sure to offset it out on the ground.
	float viewHeight = length(newWorldPos);
	if (viewHeight <= atmosphere.bottomRadius + PLANET_RADIUS_OFFSET)
	{
		// Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
		newWorldPos = normalize(newWorldPos) * (atmosphere.bottomRadius + PLANET_RADIUS_OFFSET + 0.001f);
		worldDir = normalize(newWorldPos - pc.cameraPos); tMaxMax = length(newWorldPos - pc.cameraPos);
	}

	// Move ray marching start up to top atmosphere.
	float3 worldPos = pc.cameraPos; viewHeight = length(pc.cameraPos);
	if (viewHeight >= atmosphere.topRadius)
	{
		if (!moveToTopAtmosphere(worldPos, worldDir, atmosphere.topRadius))
		{
			imageStore(cameraVolume, int3(gl.globalInvocationID), float4(float3(0.0f), 1.0f));
			return; // Ray is not intersecting the atmosphere.
		}
		float lengthToAtmosphere = length(pc.cameraPos - worldPos);
		if (tMaxMax < lengthToAtmosphere)
		{
			imageStore(cameraVolume, int3(gl.globalInvocationID), float4(float3(0.0f), 1.0f));
			return; // tMaxMax for this voxel is not within earth atmosphere.
		}

		// Now world position has been moved to the atmosphere boundary, we need to reduce tMaxMax accordingly. 
		tMaxMax = max(0.0f, tMaxMax - lengthToAtmosphere);
	}

	float sampleCount = max(1.0f, float(gl.globalInvocationID.z + 1) * 2.0f);
	ScatteringResult result = integrateScatteredLuminance(texCoords, worldPos, 
		worldDir, pc.sunDir, atmosphere, sampleCount, tMaxMax, transLUT, multiScatLUT);
	float4 color = float4(result.l, 1.0f - dot(result.transmittance, float3(1.0f / 3.0f)));
	imageStore(cameraVolume, int3(gl.globalInvocationID), color);
}