// Copyright 2022-2025 Nikita Fediuchin. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based on this: https://github.com/sebh/UnrealEngineSkyAtmosphere

#ifndef ATMOSPHERE_GSL
#define ATMOSPHERE_GSL

#include "common/math.gsl"
#include "atmosphere/constants.h"

//**********************************************************************************************************************
struct AtmosphereParams
{
	float3 rayleighScattering;
	float rayDensityExpScale;
	float3 mieExtinction;
	float mieDensityExpScale;
	float3 absorptionExtinction;
	float absDensity0LayerWidth;
	float absDensity0ConstantTerm;
	float absDensity0LinearTerm;
	float absDensity1ConstantTerm;
	float absDensity1LinearTerm;
	float bottomRadius;
	float topRadius;
	#ifdef USE_TRANSMITTANCE_LUT
	float3 mieScattering;
	float miePhaseG;
	#endif
	#ifdef USE_SCATTERING_GROUND
	float3 groundAlbedo;
	#endif
};

struct MediumSampleRGB
{
	float3 extinctionMie;
	float3 scatteringRay;
	float3 absorptionOzo;
	float3 extinction;
	#ifdef USE_TRANSMITTANCE_LUT
	float3 scatteringMie;
	float3 scattering;
	#endif
};

struct ScatteringResult
{
	float3 opticalDepth;
	#ifdef USE_TRANSMITTANCE_LUT
	float3 l;
	float3 transmittance;
	float3 multiScatAs1;
	#endif
};

//**********************************************************************************************************************
ScatteringResult initScatteringResult()
{
	ScatteringResult result;
	result.opticalDepth = float3(0.0f);
	#ifdef USE_TRANSMITTANCE_LUT
	result.l = float3(0.0f);
	result.transmittance = float3(0.0f);
	result.multiScatAs1 = float3(0.0f);
	#endif
	return result;
}

float intersectSphere(float3 rayOrigin, float3 rayDirection, float3 sphereCenter, float sphereRadius)
{
	float3 l = rayOrigin - sphereCenter;
	float a = dot(rayDirection, rayDirection);
	float b = 2.0f * dot(rayDirection, l);
	float c = dot(l, l) - sphereRadius * sphereRadius;
	float discriminant = b * b - 4.0f * a * c;
	if (discriminant < 0.0f)
		return -1.0f;

	float t0 = (-b - sqrt(discriminant)) / (2.0f * a);
	float t1 = (-b + sqrt(discriminant)) / (2.0f * a);
	if (t0 < 0.0f && t1 < 0.0f)
		return -1.0f;

	if (t0 < 0.0f) return max(0.0f, t1);
	if (t1 < 0.0f) return max(0.0f, t0);
	return max(0.0f, min(t0, t1));
}
bool moveToTopAtmosphere(inout float3 worldPos, float3 worldDir, float atmosphereTopRadius)
{
	float viewHeight = length(worldPos);
	if (viewHeight > atmosphereTopRadius)
	{
		float tTop = intersectSphere(worldPos, worldDir, float3(0.0f), atmosphereTopRadius);
		if (tTop < 0.0f)
			return false; // Ray is not intersecting the atmosphere.

		float3 upVector = worldPos / viewHeight;
		float3 upOffset = upVector * -PLANET_RADIUS_OFFSET;
		worldPos = fma(worldDir, float3(tTop), worldPos + upOffset);
	}
	return true; // OK, start tracing.
}

float miePhase(float g, float cosTheta) // Cornette-Shanks
{
	float k = (3.0f / (8.0f * M_PI)) * (1.0f - g * g) / fma(g, g, 2.0f);
	return k * fma(cosTheta, cosTheta, 1.0f) / pow(fma(g, g, 1.0f) - 2.0f * g * -cosTheta, 1.5f);
}
float rayleighPhase(float cosTheta)
{
	const float factor = 3.0f / (16.0f * M_PI);
	return factor * fma(cosTheta, cosTheta, 1.0f);
}

//**********************************************************************************************************************
MediumSampleRGB sampleMediumRGB(AtmosphereParams atmosphere, float pHeight)
{
	float viewHeight = pHeight - atmosphere.bottomRadius;
	float densityMie = exp(atmosphere.mieDensityExpScale * viewHeight);
	float densityRay = exp(atmosphere.rayDensityExpScale * viewHeight);
	float densityOzo = viewHeight < atmosphere.absDensity0LayerWidth ?
		clamp(fma(atmosphere.absDensity0LinearTerm, viewHeight, atmosphere.absDensity0ConstantTerm), 0.0f, 1.0f) :
		clamp(fma(atmosphere.absDensity1LinearTerm, viewHeight, atmosphere.absDensity1ConstantTerm), 0.0f, 1.0f);

	MediumSampleRGB s;
	s.extinctionMie = densityMie * atmosphere.mieExtinction;
	s.scatteringRay = densityRay * atmosphere.rayleighScattering;
	s.absorptionOzo = densityOzo * atmosphere.absorptionExtinction;
	s.extinction = s.extinctionMie + s.scatteringRay + s.absorptionOzo;
	#ifdef USE_TRANSMITTANCE_LUT
	s.scatteringMie = densityMie * atmosphere.mieScattering;
	s.scattering = s.scatteringMie + s.scatteringRay;
	#endif
	return s;
}

float3 getMultipleScattering(sampler2D multiScatLUT, float bottomRadius, 
	float topRadius, float pHeight, float viewZenithCosAngle)
{
	float2 texCoords = clamp(float2(fma(viewZenithCosAngle, 0.5f, 0.5f), 
		(pHeight - bottomRadius) / (topRadius - bottomRadius)), 0.0f, 1.0f);
	texCoords = (texCoords + 0.5f / MULTI_SCAT_LUT_LENGTH) * 
		(MULTI_SCAT_LUT_LENGTH / (MULTI_SCAT_LUT_LENGTH + 1.0f));
	return textureLod(multiScatLUT, texCoords, 0).rgb;
}

float2 transmittanceRmuToUV(float bottomRadius, float topRadius, float r, float mu)
{
	// Distance to top atmosphere boundary for a horizontal ray at ground level.
	float h = sqrt(max(0.0f, topRadius * topRadius - bottomRadius * bottomRadius));
	float rHor = sqrt(max(0.0f, r * r - bottomRadius * bottomRadius)); // Distance to the horizon.

	// Distance to the top atmosphere boundary for the ray (r, mu), and its minimum
	// and maximum values over all mu - obtained for (r, 1) and (r, muHorizon).
	float discriminant = fma(topRadius, topRadius, r * r * fma(mu, mu, -1.0f));
	float d = max(0.0f, fma(-r, mu, sqrt(discriminant)));
	float dMin = topRadius - r; float dMax = rHor + h;
	return float2((d - dMin) / (dMax - dMin), rHor / h);
}
float3 getTransmittance(sampler2D transLUT, float3 worldPos, float3 worldDir, float bottomRadius, float topRadius)
{
	if (intersectSphere(worldPos, worldDir, float3(0.0f), bottomRadius) >= 0.0f)
		return float3(0.0f);
	float viewHeight = length(worldPos); float3 upVector = worldPos / viewHeight;
	float viewZenithCosAngle = dot(worldDir, upVector);
	float2 uv = transmittanceRmuToUV(bottomRadius, topRadius, viewHeight, viewZenithCosAngle);
	return textureLod(transLUT, uv, 0.0f).rgb;
}

//**********************************************************************************************************************
ScatteringResult integrateScatteredLuminance(float2 texCoords, float3 worldPos, float3 worldDir, 
	float3 sunDir, const AtmosphereParams atmosphere, float sampleCountInit, float tMaxMax
	#ifdef USE_TRANSMITTANCE_LUT
	, sampler2D transLUT
	#endif
	#ifdef USE_MULTI_SCATTERING_LUT
	, sampler2D multiScatLUT
	#endif
	)
{
	ScatteringResult result = initScatteringResult();

	const float3 planetPos = float3(0.0f);
	float tBottom = intersectSphere(worldPos, worldDir, planetPos, atmosphere.bottomRadius);
	float tTop = intersectSphere(worldPos, worldDir, planetPos, atmosphere.topRadius);

	float tMax = 0.0f;
	if (tBottom < 0.0f)
	{
		// No intersection with planet nor atmosphere, stop right away. 
		if (tTop < 0.0f) return result;
		else tMax = tTop;
	}
	else
	{
		if (tTop > 0.0f)
			tMax = min(tTop, tBottom);
	}
	tMax = min(tMax, tMaxMax);

	#ifdef USE_SCAT_VAR_SAMPLE_COUNT
	float sampleCount = mix(RAY_MARCH_SPP_MIN, RAY_MARCH_SPP_MAX, 
		clamp(tMax * (1.0f / RAY_MARCH_SPP_DIST), 0.0f, 1.0f));
	float sampleCountFloor = floor(sampleCount);
	// Rescale tMax to map to the last entire step segment.
	float invSampleCount = 1.0f / sampleCount;
	float tMaxFloor = tMax * sampleCountFloor * invSampleCount;
	sampleCountFloor = 1.0f / sampleCountFloor;
	#else
	float sampleCount = sampleCountInit; 
	float invSampleCount = 1.0f / sampleCount;
	#endif

	const float sampleSegmentT = 0.3f; float deltaT = tMax * invSampleCount;
	float3 opticalDepth = float3(0.0f); float t = 0.0f; 

	#ifdef USE_TRANSMITTANCE_LUT
	const float uniformPhase = 1.0f / (4.0f * M_PI);
	float3 wi = sunDir; float3 wo = worldDir; float cosTheta = dot(wi, wo);
	// Negate cosTheta because due to WorldDir being a "in" direction.
	float miePhaseValue = miePhase(atmosphere.miePhaseG, -cosTheta);	
	float rayleighPhaseValue = rayleighPhase(cosTheta);
	const float3 globalL = float3(1.0f); // Light illuminance.
	float3 l = float3(0.0f); float3 throughput = float3(1.0f);
	#endif

	for (float i = 0.0f; i < sampleCount; i += 1.0f)
	{
		#ifdef USE_SCAT_VAR_SAMPLE_COUNT
			// More expensive but artefact free.
			float t0 = i * sampleCountFloor; float t1 = (i + 1.0f) * sampleCountFloor;
			t0 *= t0; t1 *= t1; // Non linear distribution of sample within the range.
			t0 *= tMaxFloor; // Make t0 and t1 world space distances.

			if (t1 > 1.0f) t1 = tMax;
			else t1 = tMaxFloor * t1;
			t = fma(t1 - t0, sampleSegmentT, t0);
			deltaT = t1 - t0;
		#else
			// Exact difference, important for accuracy of multiple scattering.
			float newT = tMax * (i + sampleSegmentT) * invSampleCount;
			deltaT = newT - t; t = newT;
		#endif

		float3 p = fma(float3(t), worldDir, worldPos);
		float pHeight = length(p); float3 upVector = p / pHeight;
		float sunZenithCosAngle = dot(sunDir, upVector);
		MediumSampleRGB medium = sampleMediumRGB(atmosphere, pHeight);
		float3 sampleOpticalDepth = medium.extinction * deltaT;
		float3 sampleTransmittance = exp(-sampleOpticalDepth);
		opticalDepth += sampleOpticalDepth;

		#ifdef USE_MULTI_SCATTERING_LUT
		float3 multiScatLuminance = getMultipleScattering(multiScatLUT, 
			atmosphere.bottomRadius, atmosphere.topRadius, pHeight, sunZenithCosAngle);
		#else
		const float3 multiScatLuminance = float3(0.0f);
		#endif

		#ifdef USE_TRANSMITTANCE_LUT
		float2 uv = transmittanceRmuToUV(atmosphere.bottomRadius, 
			atmosphere.topRadius, pHeight, sunZenithCosAngle);
		float3 transmittanceToSun = textureLod(transLUT, uv, 0).rgb;

		#ifdef USE_SCAT_MIE_RAY_PHASE
		float3 phaseTimesScattering = medium.scatteringMie * 
			miePhaseValue + medium.scatteringRay * rayleighPhaseValue;
		#else
		float3 phaseTimesScattering = medium.scattering * uniformPhase;
		#endif

		float tPlanet = intersectSphere(p, sunDir, fma(upVector, 
			float3(PLANET_RADIUS_OFFSET), planetPos), atmosphere.bottomRadius);
		float planetShadow = tPlanet >= 0.0f ? 0.0f : 1.0f;

		#if USE_ATMOSPHERE_SHADOWS
		float shadow = getShadow(atmosphere, p);
		#else
		const float shadow = 1.0f;
		#endif

		float3 s = globalL * (planetShadow * shadow * transmittanceToSun * 
			phaseTimesScattering + multiScatLuminance * medium.scattering);
		// 1 is the integration of luminance over the 4pi of a sphere, with isotropic phase function of 1 / (4 * PI).
		result.multiScatAs1 += throughput * medium.scattering * deltaT;

		// Integrate along the current step segment.
		float3 sInt = (s - s * sampleTransmittance) / max(medium.extinction, FLOAT_EPS9); 
		l += throughput * sInt; // Accumulate and also take into account the transmittance from previous steps.
		throughput *= sampleTransmittance;
		#endif
	}

	#ifdef USE_SCATTERING_GROUND
	if (tMax == tBottom && tBottom > 0.0f)
	{
		// Account for bounced light off the planet
		float3 p = fma(float3(tBottom), worldDir, worldPos);
		float pHeight = length(p); float3 upVector = p / pHeight;
		float sunZenithCosAngle = dot(sunDir, upVector);
		float2 uv = transmittanceRmuToUV(atmosphere.bottomRadius, 
			atmosphere.topRadius, pHeight, sunZenithCosAngle);
		float3 transmittanceToSun = textureLod(transLUT, uv, 0).rgb;
		float nol = clamp(dot(normalize(upVector), normalize(sunDir)), 0.0f, 1.0f);
		l += globalL * transmittanceToSun * throughput * nol * atmosphere.groundAlbedo * M_1_PI;
	}
	#endif

	result.opticalDepth = opticalDepth;
	#ifdef USE_TRANSMITTANCE_LUT
	result.l = l;
	result.transmittance = throughput;
	#endif
	return result;
}

#endif // ATMOSPHERE_GSL