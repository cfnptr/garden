// Copyright 2022-2025 Nikita Fediuchin. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based on this: https://github.com/sebh/UnrealEngineSkyAtmosphere

#ifndef ATMOSPHERE_GSL
#define ATMOSPHERE_GSL

#include "common/math.gsl"

#define TRANSMITTANCE_LUT_WIDTH 256
#define TRANSMITTANCE_LUT_HEIGHT 64

#define MULTI_SCAT_LUT_LENGTH 32

#define SCATTERING_LUT_R_SIZE 32
#define SCATTERING_LUT_MU_SIZE 128
#define SCATTERING_LUT_MU_S_SIZE 32
#define SCATTERING_LUT_NU_SIZE 8

#define IRRADIANCE_LUT_WIDTH 64
#define IRRADIANCE_LUT_HEIGHT 16

#define PLANET_RADIUS_OFFSET 0.01f

//**********************************************************************************************************************
struct AtmosphereParams
{
	float3 rayleighScattering;
	float rayDensityExpScale;
	float3 mieExtinction;
	float mieDensityExpScale;
	float3 absorptionExtinction;
	float miePhaseG;
	float absDensity0LayerWidth;
	float absDensity0ConstantTerm;
	float absDensity0LinearTerm;
	float absDensity1ConstantTerm;
	float absDensity1LinearTerm;
	float bottomRadius;
	float topRadius;
	#ifndef USE_OPTICAL_DEPTH_ONLY
	float3 mieScattering;
	float3 groundAlbedo;
	#endif
};

struct MediumSampleRGB
{
	float3 extinctionMie;
	float3 scatteringRay;
	float3 absorptionOzo;
	float3 extinction;
	#ifndef USE_OPTICAL_DEPTH_ONLY
	float3 scatteringMie;
	float3 scattering;
	float3 albedo;
	#endif
};

struct ScatteringResult
{
	float3 opticalDepth;
	#ifndef USE_OPTICAL_DEPTH_ONLY
	float3 l;
	float3 transmittance;
	float3 multiScatAs1;
	float3 newMultiScatStep0Out;
	float3 newMultiScatStep1Out;
	#endif
};

//**********************************************************************************************************************
ScatteringResult initScatteringResult()
{
	ScatteringResult result;
	result.opticalDepth = float3(0.0f);
	#ifndef USE_OPTICAL_DEPTH_ONLY
	result.l = float3(0.0f);
	result.transmittance = float3(0.0f);
	result.multiScatAs1 = float3(0.0f);
	result.newMultiScatStep0Out = float3(0.0f);
	result.newMultiScatStep1Out = float3(0.0f);
	#endif
	return result;
}

float intersectSphere(float3 rayOrigin, float3 rayDirection, float3 sphereCenter, float sphereRadius)
{
	float3 l = rayOrigin - sphereCenter;
	float a = dot(rayDirection, rayDirection);
	float b = 2.0f * dot(rayDirection, l);
	float c = dot(l, l) - sphereRadius * sphereRadius;
	float discriminant = b * b - 4.0f * a * c;
	if (discriminant < 0.0f)
		return -1.0f;

	float t0 = (-b - sqrt(discriminant)) / (2.0f * a);
	float t1 = (-b + sqrt(discriminant)) / (2.0f * a);
	if (t0 < 0.0f && t1 < 0.0f)
		return -1.0f;

	if (t0 < 0.0f) return max(0.0f, t1);
	if (t1 < 0.0f) return max(0.0f, t0);
	return max(0.0f, min(t0, t1));
}

float miePhase(float g, float cosTheta) // Cornette-Shanks
{
	float k = 3.0f / (8.0f * M_PI) * (1.0f - g * g) / (2.0f + g * g);
	return k * (1.0f + cosTheta * cosTheta) / pow(1.0f + g * g - 2.0f * g * -cosTheta, 1.5f);
}
float rayleighPhase(float cosTheta)
{
	float factor = 3.0f / (16.0f * M_PI);
	return factor * (1.0f + cosTheta * cosTheta);
}

//**********************************************************************************************************************
MediumSampleRGB sampleMediumRGB(AtmosphereParams atmosphere, float pHeight)
{
	float viewHeight = pHeight - atmosphere.bottomRadius;
	float densityMie = exp(atmosphere.mieDensityExpScale * viewHeight);
	float densityRay = exp(atmosphere.rayDensityExpScale * viewHeight);
	float densityOzo = clamp(viewHeight < atmosphere.absDensity0LayerWidth ?
		atmosphere.absDensity0LinearTerm * viewHeight + atmosphere.absDensity0ConstantTerm :
		atmosphere.absDensity1LinearTerm * viewHeight + atmosphere.absDensity1ConstantTerm, 0.0f, 1.0f);

	MediumSampleRGB s;
	s.extinctionMie = densityMie * atmosphere.mieExtinction;
	s.scatteringRay = densityRay * atmosphere.rayleighScattering;
	s.absorptionOzo = densityOzo * atmosphere.absorptionExtinction;
	s.extinction = s.extinctionMie + s.scatteringRay + s.absorptionOzo;
	#ifndef USE_OPTICAL_DEPTH_ONLY
	s.scatteringMie = densityMie * atmosphere.mieScattering;
	s.scattering = s.scatteringMie + s.scatteringRay;
	s.albedo = s.scattering / max(0.001f, s.extinction);
	#endif
	return s;
}

float3 getMultipleScattering(sampler2D multiScatLUT, 
	AtmosphereParams atmosphere, float3 worldPos, float viewZenithCosAngle)
{
	float2 texCoords = clamp(float2(viewZenithCosAngle * 0.5f + 0.5f, (length(worldPos) - 
		atmosphere.bottomRadius) / (atmosphere.topRadius - atmosphere.bottomRadius)), 0.0f, 1.0f);
	texCoords = (texCoords + 0.5f / MULTI_SCAT_LUT_LENGTH) * 
		(MULTI_SCAT_LUT_LENGTH / (MULTI_SCAT_LUT_LENGTH + 1.0f));
	return textureLod(multiScatLUT, texCoords, 0).rgb;
}

float2 transmittanceRmuToUV(AtmosphereParams atmosphere, float r, float mu)
{
	// Distance to top atmosphere boundary for a horizontal ray at ground level.
	float h = sqrt(max(0.0f, atmosphere.topRadius * atmosphere.topRadius -
		atmosphere.bottomRadius * atmosphere.bottomRadius));
	float rHor = sqrt(max(0.0f, r * r - atmosphere.bottomRadius * atmosphere.bottomRadius)); // Distance to the horizon.

	// Distance to the top atmosphere boundary for the ray (r, mu), and its minimum
	// and maximum values over all mu - obtained for (r, 1) and (r, muHorizon).
	float discriminant = r * r * (mu * mu - 1.0) + atmosphere.topRadius * atmosphere.topRadius;
	float d = max(0.0, (-r * mu + sqrt(discriminant)));
	float dMin = atmosphere.topRadius - r; float dMax = rHor + h;
	float2 muR = float2((d - dMin) / (dMax - dMin), rHor / h);

	const float2 transmittanceLutSize = float2(TRANSMITTANCE_LUT_WIDTH, TRANSMITTANCE_LUT_HEIGHT);
	return 0.5f / transmittanceLutSize + muR * (1.0f - 1.0f / transmittanceLutSize);
}

//**********************************************************************************************************************
ScatteringResult integrateScatteredLuminance(float2 texCoords, float3 worldPos, float3 worldDir, float3 sunDir, 
	const AtmosphereParams atmosphere, float sampleCountInit, float depthBufferValue, float tMaxMax
	#ifndef USE_OPTICAL_DEPTH_ONLY
	, sampler2D transLUT, sampler2D multiScatLUT
	#endif
	)
{
	ScatteringResult result = initScatteringResult();

	const float3 planetPos = float3(0.0f);
	float tBottom = intersectSphere(worldPos, worldDir, planetPos, atmosphere.bottomRadius);
	float tTop = intersectSphere(worldPos, worldDir, planetPos, atmosphere.topRadius);

	float tMax = 0.0f;
	if (tBottom < 0.0f)
	{
		// No intersection with planet nor atmosphere, stop right away. 
		if (tTop < 0.0f) return result;
		else tMax = tTop;
	}
	else
	{
		if (tTop > 0.0f)
			tMax = min(tTop, tBottom);
	}

	/* TODO: looks like it is used only for path tracing, remove.
	if (depthBufferValue >= 0.0f && depthBufferValue < 1.0f)
	{
		float3 clipSpace = float3(texCoords * float2(2.0f, -2.0f) - float2(1.0f, -1.0f), depthBufferValue);
		float4 depthBufferWorldPos = gSkyInvViewProjMat * float4(clipSpace, 1.0f);
		depthBufferWorldPos /= depthBufferWorldPos.w;

		// Apply planet offset to go back to origin as top of planet mode.
		float tDepth = length(depthBufferWorldPos.xyz - (worldPos + 
			float3(0.0f, 0.0f, -atmosphere.bottomRadius)));  
		if (tDepth < tMax) tMax = tDepth;
	}
	*/
	tMax = min(tMax, tMaxMax);

	float sampleCount = sampleCountInit; float sampleCountFloor = sampleCountInit; float tMaxFloor = tMax;
	#ifdef USE_SCAT_VAR_SAMPLE_COUNT
		sampleCount = mix(RAY_MARCH_SPP_MIN, RAY_MARCH_SPP_MAX, clamp(tMax * 0.01f, 0.0f, 1.0f));
		sampleCountFloor = floor(sampleCount);
		// Rescale tMax to map to the last entire step segment.
		tMaxFloor = tMax * sampleCountFloor / sampleCount;	
	#endif

	const float sampleSegmentT = 0.3f; float deltaT = tMax / sampleCount;
	float3 opticalDepth = float3(0.0f); float t = 0.0f; 

	#ifndef USE_OPTICAL_DEPTH_ONLY
	const float uniformPhase = 1.0f / (4.0f * M_PI);
	float3 wi = sunDir; float3 wo = worldDir; float cosTheta = dot(wi, wo);
	// Negate cosTheta because due to WorldDir being a "in" direction.
	float miePhaseValue = miePhase(atmosphere.miePhaseG, -cosTheta);	
	float rayleighPhaseValue = rayleighPhase(cosTheta);
	const float3 globalL = 1.0f; // Light illuminance.
	float3 l = 0.0f; float3 throughput = 1.0f;
	#endif

	for (float s = 0.0f; s < sampleCount; s += 1.0f)
	{
		#ifdef USE_SCAT_VAR_SAMPLE_COUNT
			// More expensive but artefact free.
			float t0 = s / sampleCountFloor;
			float t1 = (s + 1.0f) / sampleCountFloor;
			// Non linear distribution of sample within the range.
			t0 = t0 * t0; t1 = t1 * t1;
			// Make t0 and t1 world space distances.
			t0 = tMaxFloor * t0;

			if (t1 > 1.0f) t1 = tMax;
			else t1 = tMaxFloor * t1;
			t = t0 + (t1 - t0) * sampleSegmentT;
			deltaT = t1 - t0;
		#else
			// Exact difference, important for accuracy of multiple scattering
			float newT = tMax * (s + sampleSegmentT) / sampleCount;
			deltaT = newT - t; t = newT;
		#endif

		float3 p = worldPos + t * worldDir;
		float pHeight = length(p); float3 upVector = p / pHeight;
		MediumSampleRGB medium = sampleMediumRGB(atmosphere, pHeight);
		float3 sampleOpticalDepth = medium.extinction * deltaT;
		float3 sampleTransmittance = exp(-sampleOpticalDepth);
		opticalDepth += sampleOpticalDepth;

		#ifndef USE_OPTICAL_DEPTH_ONLY
		float sunZenithCosAngle = dot(sunDir, upVector);
		float2 uv = transmittanceRmuToUV(atmosphere, pHeight, sunZenithCosAngle);
		float3 transmittanceToSun = textureLod(transLUT, uv, 0).rgb;

		#ifdef USE_MIE_RAY_PHASE
		float3 phaseTimesScattering = medium.scatteringMie * 
			miePhaseValue + medium.scatteringRay * rayleighPhaseValue;
		#else
		float3 phaseTimesScattering = medium.scattering * uniformPhase;
		#endif

		float tPlanet = raySphereIntersectNearest(p, sunDir, planetPos + 
			PLANET_RADIUS_OFFSET * upVector, atmosphere.bottomRadius);
		float planetShadow = tPlanet >= 0.0f ? 0.0f : 1.0f;

		#ifdef USE_MULTI_SCATTERING
		float3 multiScatteredLuminance = getMultipleScattering(multiScatLUT, atmosphere, p, sunZenithCosAngle);
		#else
		const float3 multiScatteredLuminance = float3(0.0f);
		#endif

		#if USE_SCAT_SHADOW_MAP
		// First evaluate opaque shadow
		float shadow = getShadow(atmosphere, p);
		#else
		const float shadow = 1.0f;
		#endif

		float3 s = globalL * (planetShadow * shadow * transmittanceToSun * 
			phaseTimesScattering + multiScatteredLuminance * medium.scattering);

		// When using the power serie to accumulate all scattering order, serie r must be < 1 for a serie to converge.
		// Under extreme coefficient, MultiScatAs1 can grow larger and thus result in broken visuals.
		float3 msInt = (medium.scattering - medium.scattering * sampleTransmittance) / medium.extinction;
		result.multiScatAs1 += throughput * msInt;

		float3 newMS = planetShadow * transmittanceToSun * medium.scattering * uniformPhase;
		result.newMultiScatStep0Out += throughput * (newMS - newMS * sampleTransmittance) / medium.extinction;

		newMS = medium.scattering * uniformPhase * multiScatteredLuminance;
		result.newMultiScatStep1Out += throughput * (newMS - newMS * sampleTransmittance) / medium.extinction;

		float3 sInt = (s - s * sampleTransmittance) / medium.extinction; // Integrate along the current step segment.
		l += throughput * sInt; // Accumulate and also take into account the transmittance from previous steps.
		throughput *= sampleTransmittance;
		#endif
	}

	#if defined(USE_SCATTERING_GROUND) && !defined(USE_OPTICAL_DEPTH_ONLY)
	if (tMax == tBottom && tBottom > 0.0)
	{
		// Account for bounced light off the planet
		float3 p = worldPos + tBottom * worldDir;
		float pHeight = length(p); float3 upVector = p / pHeight;
		float sunZenithCosAngle = dot(sunDir, upVector);
		float2 uv = transmittanceRmuToUV(atmosphere, pHeight, sunZenithCosAngle);
		float3 transmittanceToSun = textureLod(transLUT, uv, 0).rgb;
		float nol = clamp(dot(normalize(upVector), normalize(sunDir)), 0.0f, 1.0f);
		l += globalL * transmittanceToSun * throughput * nol * atmosphere.groundAlbedo / M_PI;
	}
	#endif

	result.opticalDepth = opticalDepth;
	#ifndef USE_OPTICAL_DEPTH_ONLY
	result.l = l;
	result.transmittance = throughput;
	#endif
	return result;
}

#endif // ATMOSPHERE_GSL