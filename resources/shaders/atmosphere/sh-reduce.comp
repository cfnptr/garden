// Copyright 2022-2025 Nikita Fediuchin. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "common/sh.gsl"

localSize = 64, 1, 1;

buffer restrict ShCache
{
	volatile uint32 counter;
	float4 cache[];
} sh;

uniform pushConstants
{
	uint32 offset;
} pc;

shared float3 shShared[576]; // 64 * SH_COEFF_COUNT

void main()
{
	uint32 localIndex = gl.localInvocationIndex;
	uint32 dstIndex = localIndex * SH_COEFF_COUNT;

	if (gl.globalInvocationID.x + pc.offset < sh.counter)
	{
		uint32 srcIndex = (gl.globalInvocationID.x + pc.offset) * SH_COEFF_COUNT;
		for (uint32 i = 0; i < SH_COEFF_COUNT; i++)
			shShared[dstIndex + i] = sh.cache[srcIndex + i].rgb;
	}
	else
	{
		for (uint32 i = 0; i < SH_COEFF_COUNT; i++)
			shShared[dstIndex + i] = float3(0.0f);
	}
	barrier();

	// TODO: add subgroupVote implementation enabled by spec const.
	for (uint32 stride = (64 >> 1); stride > 0; stride >>= 1)
	{
		if (localIndex < stride)
		{
			uint32 srcIndex = (localIndex + stride) * SH_COEFF_COUNT;
			for (uint32 i = 0; i < SH_COEFF_COUNT; i++)
				shShared[dstIndex + i] += shShared[srcIndex + i];
		}
		barrier();
	}

	if (localIndex == 0)
	{
		uint32 index = atomicAdd(sh.counter, 1) * SH_COEFF_COUNT;
		for (uint32 i = 0; i < SH_COEFF_COUNT; i++)
			sh.cache[index + i] = float4(shShared[i], 0.0f);
	}
}